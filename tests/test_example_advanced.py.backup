"""
Przykłady zaawansowanych technik testowania
Ten plik pokazuje różne podejścia do testowania API
"""
import json
import pytest
from unittest.mock import patch, MagicMock
from datetime import datetime


class TestAdvancedTechniques:
    """Zaawansowane techniki testowania"""

    def test_api_response_structure(self, client, auth_headers_admin):
        """Test struktury odpowiedzi API"""
        response = client.get('/api/Customers/', headers=auth_headers_admin)

        if response.status_code == 200:
            data = json.loads(response.data)

            # Sprawdź czy odpowiedź to lista
            assert isinstance(data, list)

            # Jeśli są jakieś klienci, sprawdź strukturę
            if len(data) > 0:
                customer = data[0]
                # Sprawdź czy mają wymagane pola
                required_fields = ['id', 'name']
                for field in required_fields:
                    assert field in customer

    def test_pagination_if_exists(self, client, auth_headers_admin):
        """Test paginacji jeśli jest zaimplementowana"""
        response = client.get('/api/Customers/?page=1&limit=10',
                              headers=auth_headers_admin)

        # Test powinien działać niezależnie od implementacji paginacji
        assert response.status_code in [200, 400, 404]

    def test_filtering_if_exists(self, client, auth_headers_admin):
        """Test filtrowania jeśli jest zaimplementowane"""
        response = client.get('/api/Customers/?search=Test',
                              headers=auth_headers_admin)

        # Test powinien działać niezależnie od implementacji filtrowania
        assert response.status_code in [200, 400, 404]

    def test_sorting_if_exists(self, client, auth_headers_admin):
        """Test sortowania jeśli jest zaimplementowane"""
        response = client.get('/api/Customers/?sort=name&order=asc',
                              headers=auth_headers_admin)

        # Test powinien działać niezależnie od implementacji sortowania
        assert response.status_code in [200, 400, 404]

    def test_error_handling(self, client, auth_headers_admin):
        """Test obsługi błędów"""
        # Próba utworzenia klienta z nieprawidłowymi danymi
        response = client.post('/api/Customers/',
                               headers=auth_headers_admin,
                               data=json.dumps({}),
                               content_type='application/json')

        # Powinien zwrócić błąd lub utworzyć z domyślnymi wartościami
        assert response.status_code in [200, 201, 400, 422, 500]

    def test_concurrent_requests(self, client, auth_headers_admin):
        """Test równoczesnych żądań (symulacja)"""
        # Wykonaj kilka żądań pod rząd
        responses = []
        for i in range(5):
            response = client.get('/api/Customers/', headers=auth_headers_admin)
            responses.append(response)

        # Wszystkie powinny zwrócić odpowiedź
        for response in responses:
            assert response.status_code in [200, 401, 500]

    def test_large_data_handling(self, client, auth_headers_admin):
        """Test obsługi dużej ilości danych"""
        # Próba utworzenia klienta z długimi danymi
        long_string = "A" * 1000
        response = client.post('/api/Customers/',
                               headers=auth_headers_admin,
                               data=json.dumps({
                                   'name': long_string,
                                   'email': 'test@test.com'
                               }),
                               content_type='application/json')

        # Powinien obsłużyć lub odrzucić zbyt długie dane
        assert response.status_code in [200, 201, 400, 413, 422]

    def test_special_characters_handling(self, client, auth_headers_admin):
        """Test obsługi znaków specjalnych"""
        special_chars = "!@#$%^&*(){}[]<>?/|\\~`"
        response = client.post('/api/Customers/',
                               headers=auth_headers_admin,
                               data=json.dumps({
                                   'name': special_chars,
                                   'email': 'special@test.com'
                               }),
                               content_type='application/json')

        # Powinien obsłużyć znaki specjalne
        assert response.status_code in [200, 201, 400, 422]

    def test_sql_injection_protection(self, client, auth_headers_admin):
        """Test ochrony przed SQL Injection"""
        sql_injection = "'; DROP TABLE Customers; --"
        response = client.post('/api/Customers/',
                               headers=auth_headers_admin,
                               data=json.dumps({
                                   'name': sql_injection,
                                   'email': 'sql@test.com'
                               }),
                               content_type='application/json')

        # Powinien bezpiecznie obsłużyć próbę SQL injection
        assert response.status_code in [200, 201, 400, 422]

        # Sprawdź czy tabela Customers nadal istnieje
        get_response = client.get('/api/Customers/', headers=auth_headers_admin)
        assert get_response.status_code in [200, 401]

    def test_xss_protection(self, client, auth_headers_admin):
        """Test ochrony przed XSS"""
        xss_attempt = "<script>alert('XSS')</script>"
        response = client.post('/api/Customers/',
                               headers=auth_headers_admin,
                               data=json.dumps({
                                   'name': xss_attempt,
                                   'email': 'xss@test.com'
                               }),
                               content_type='application/json')

        # Powinien bezpiecznie obsłużyć próbę XSS
        assert response.status_code in [200, 201, 400, 422]

    def test_rate_limiting_if_exists(self, client, auth_headers_admin):
        """Test rate limiting jeśli jest zaimplementowany"""
        # Wykonaj wiele żądań szybko
        responses = []
        for i in range(50):
            response = client.get('/api/Customers/', headers=auth_headers_admin)
            responses.append(response.status_code)

        # Jeśli jest rate limiting, powinny pojawić się błędy 429
        # Jeśli nie ma, wszystkie powinny zwrócić 200
        assert all(status in [200, 429] for status in responses)

    def test_content_type_validation(self, client, auth_headers_admin):
        """Test walidacji Content-Type"""
        # Próba wysłania danych bez Content-Type
        response = client.post('/api/Customers/',
                               headers={'Authorization': auth_headers_admin['Authorization']},
                               data='{"name": "Test"}')

        # Powinien obsłużyć brak Content-Type
        assert response.status_code in [200, 201, 400, 415]

    def test_method_not_allowed(self, client, auth_headers_admin):
        """Test obsługi niedozwolonych metod HTTP"""
        # Próba użycia PATCH zamiast PUT
        response = client.patch('/api/Customers/1',
                                headers=auth_headers_admin,
                                data=json.dumps({'name': 'Test'}),
                                content_type='application/json')

        # Powinien zwrócić 405 Method Not Allowed lub obsłużyć jako PUT
        assert response.status_code in [200, 405]

    def test_case_sensitivity(self, client, auth_headers_admin):
        """Test wrażliwości na wielkość liter w URL"""
        # Próba użycia różnych wielkości liter
        response1 = client.get('/api/Customers/', headers=auth_headers_admin)
        response2 = client.get('/api/customers/', headers=auth_headers_admin)

        # Sprawdź czy endpointy są case-sensitive
        assert response1.status_code in [200, 401]
        assert response2.status_code in [200, 401, 404]


class TestPerformance:
    """Testy wydajnościowe (podstawowe)"""

    def test_response_time_get_customers(self, client, auth_headers_admin):
        """Test czasu odpowiedzi GET /api/Customers/"""
        import time

        start_time = time.time()
        response = client.get('/api/Customers/', headers=auth_headers_admin)
        end_time = time.time()

        response_time = end_time - start_time

        # Odpowiedź powinna przyjść w rozsądnym czasie (< 2 sekundy)
        assert response_time < 2.0
        assert response.status_code in [200, 401]

    def test_response_time_create_customer(self, client, auth_headers_admin):
        """Test czasu odpowiedzi POST /api/Customers/"""
        import time

        start_time = time.time()
        response = client.post('/api/Customers/',
                               headers=auth_headers_admin,
                               data=json.dumps({
                                   'name': 'Performance Test Customer',
                                   'email': 'perf@test.com'
                               }),
                               content_type='application/json')
        end_time = time.time()

        response_time = end_time - start_time

        # Utworzenie zasobu powinno być szybkie (< 3 sekundy)
        assert response_time < 3.0
        assert response.status_code in [200, 201, 400, 401]


class TestDataValidation:
    """Testy walidacji danych"""

    def test_email_validation(self, client, auth_headers_admin):
        """Test walidacji emaila"""
        invalid_emails = [
            'invalid',
            '@invalid.com',
            'invalid@',
            'invalid@.com',
            'invalid..email@test.com'
        ]

        for invalid_email in invalid_emails:
            response = client.post('/api/Customers/',
                                   headers=auth_headers_admin,
                                   data=json.dumps({
                                       'name': 'Test',
                                       'email': invalid_email
                                   }),
                                   content_type='application/json')

            # Powinien odrzucić nieprawidłowy email lub go zaakceptować (zależnie od implementacji)
            assert response.status_code in [200, 201, 400, 422]

    def test_required_fields(self, client, auth_headers_admin):
        """Test wymaganych pól"""
        # Próba utworzenia klienta bez wymaganych pól
        response = client.post('/api/Customers/',
                               headers=auth_headers_admin,
                               data=json.dumps({}),
                               content_type='application/json')

        # Powinien zwrócić błąd lub utworzyć z domyślnymi wartościami
        assert response.status_code in [200, 201, 400, 422]

    def test_data_type_validation(self, client, auth_headers_admin):
        """Test walidacji typów danych"""
        # Próba wysłania stringa zamiast liczby
        response = client.post('/api/Customers/',
                               headers=auth_headers_admin,
                               data=json.dumps({
                                   'name': 'Test',
                                   'email': 'test@test.com',
                                   'assignedGroupId': 'not_a_number'
                               }),
                               content_type='application/json')

        # Powinien odrzucić nieprawidłowy typ danych
        assert response.status_code in [200, 201, 400, 422]
