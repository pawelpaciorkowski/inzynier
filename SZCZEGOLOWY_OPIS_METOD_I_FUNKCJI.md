# üîç SZCZEG√ì≈ÅOWY OPIS METOD I FUNKCJI - OBRONA

> **Projekt:** Zintegrowany System CRM
> **Autor:** Pawe≈Ç Paciorkowski
> **Cel:** Szczeg√≥≈Çowe wyja≈õnienie ka≈ºdej kluczowej metody i funkcji w systemie

---

## üìã SPIS TRE≈öCI

1. [Backend - Inicjalizacja Aplikacji](#backend---inicjalizacja-aplikacji)
2. [Backend - Middleware i Autoryzacja](#backend---middleware-i-autoryzacja)
3. [Backend - Kontroler Uwierzytelniania](#backend---kontroler-uwierzytelniania)
4. [Frontend Web - Kontekst Autoryzacji](#frontend-web---kontekst-autoryzacji)
5. [Mobile - Kontekst Autoryzacji](#mobile---kontekst-autoryzacji)
6. [Backend - Modele Danych](#backend---modele-danych)
7. [Frontend - Komponenty i Routing](#frontend---komponenty-i-routing)

---

## üêç BACKEND - INICJALIZACJA APLIKACJI

### **Plik: `backend-python/app/__init__.py`**

#### **Funkcja `create_app()` - Factory Pattern**

```python
def create_app():
    """Tworzy i konfiguruje aplikacjƒô Flask"""
    app = Flask(__name__)
    app.config.from_object(Config)
    app.url_map.strict_slashes = False

    CORS(app, origins=['http://localhost:3000', 'http://localhost:8100',
                       'http://localhost:8082', 'http://localhost:5173'])

    init_database(app)

    # Importowanie i rejestrowanie blueprint√≥w
    from app.controllers.auth import auth_bp
    from app.controllers.customers import customers_bp
    # ... inne importy

    app.register_blueprint(auth_bp, url_prefix='/api/Auth')
    app.register_blueprint(customers_bp, url_prefix='/api/Customers')
    # ... inne rejestracje

    return app
```

**Wyja≈õnienie krok po kroku:**

1. **`app = Flask(__name__)`**
   - Tworzy instancjƒô aplikacji Flask
   - `__name__` to nazwa modu≈Çu Python - Flask u≈ºywa tego do okre≈õlenia lokalizacji zasob√≥w

2. **`app.config.from_object(Config)`**
   - ≈Åaduje konfiguracjƒô z obiektu `Config` (klasa z pliku `config.py`)
   - Zawiera ustawienia jak: SECRET_KEY, DATABASE_URI, JWT_SECRET_KEY
   - Pozwala mieƒá r√≥≈ºne konfiguracje dla development/production

3. **`app.url_map.strict_slashes = False`**
   - Wy≈ÇƒÖcza ≈õcis≈Çe sprawdzanie ko≈Ñcowych slashy w URL
   - `/api/Customers` i `/api/Customers/` bƒôdƒÖ traktowane tak samo
   - Wa≈ºne dla sp√≥jno≈õci API - klienci mogƒÖ nie dodawaƒá slasha

4. **`CORS(app, origins=[...])`**
   - **CORS** = Cross-Origin Resource Sharing
   - Pozwala aplikacjom z innych domen (origins) ≈ÇƒÖczyƒá siƒô z API
   - Lista origins zawiera adresy lokalnych serwer√≥w development:
     - `localhost:3000` - standardowy port React
     - `localhost:8100` - Expo mobile development
     - `localhost:8082` - alternatywny port Expo
     - `localhost:5173` - Vite development server
   - Bez CORS przeglƒÖdarka blokuje requesty z innych domen (security)

5. **`init_database(app)`**
   - Inicjalizuje po≈ÇƒÖczenie z bazƒÖ danych
   - Tworzy tabele je≈õli nie istniejƒÖ
   - Binduje SQLAlchemy ORM do aplikacji Flask

6. **`app.register_blueprint(auth_bp, url_prefix='/api/Auth')`**
   - **Blueprint** to modu≈Ç Flask grupujƒÖcy powiƒÖzane endpointy
   - `auth_bp` zawiera endpointy logowania, rejestracji
   - `url_prefix` dodaje prefix do wszystkich ≈õcie≈ºek w blueprint
   - Przyk≈Çad: `@auth_bp.route('/login')` ‚Üí `/api/Auth/login`
   - Zalety blueprint√≥w:
     - Modularno≈õƒá - ≈Çatwe zarzƒÖdzanie kodem
     - Reu≈ºywalno≈õƒá - mo≈ºliwo≈õƒá u≈ºywania w wielu aplikacjach
     - Separation of concerns - ka≈ºdy modu≈Ç odpowiada za swojƒÖ domenƒô

**Wzorzec Factory Pattern:**
- Zamiast tworzyƒá app globalnie, tworzymy funkcjƒô `create_app()`
- Zalety:
  - Mo≈ºliwo≈õƒá tworzenia wielu instancji app (dla test√≥w)
  - ≈Åatwiejsze przekazywanie r√≥≈ºnych konfiguracji
  - Lepsze testowanie - ka≈ºdy test mo≈ºe mieƒá ≈õwie≈ºƒÖ instancjƒô

---

## üîê BACKEND - MIDDLEWARE I AUTORYZACJA

### **Plik: `backend-python/app/middleware.py`**

#### **Dekorator `@require_auth` - Ochrona Endpoint√≥w**

```python
def require_auth(f):
    """Dekorator wymagajƒÖcy autoryzacji"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        token = None

        # Sprawd≈∫ nag≈Ç√≥wek Authorization
        if 'Authorization' in request.headers:
            auth_header = request.headers['Authorization']
            try:
                # Format: "Bearer <token>"
                token = auth_header.split(" ")[1]
            except IndexError:
                return jsonify({'error': 'Token nieprawid≈Çowy'}), 401

        if not token:
            return jsonify({'error': 'Brak tokenu autoryzacji'}), 401

        try:
            # Dekoduj token
            data = jwt.decode(token, Config.JWT_SECRET_KEY, algorithms=['HS256'])
            current_user_id = data.get('user_id') or data.get('sub')

            if not current_user_id:
                return jsonify({'error': 'Token nieprawid≈Çowy'}), 401

            # Zapisz ID u≈ºytkownika w kontek≈õcie Flask
            g.user_id = current_user_id

        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token wygas≈Ç'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Token nieprawid≈Çowy'}), 401

        return f(*args, **kwargs)

    return decorated_function
```

**Wyja≈õnienie krok po kroku:**

1. **`def require_auth(f):`**
   - To **dekorator** - funkcja, kt√≥ra "opakowuje" innƒÖ funkcjƒô
   - Przyjmuje funkcjƒô `f` (endpoint) i dodaje do niej funkcjonalno≈õƒá autoryzacji
   - Przyk≈Çad u≈ºycia: `@require_auth` nad funkcjƒÖ endpointu

2. **`@wraps(f)`**
   - Dekorator z `functools` zachowujƒÖcy metadane oryginalnej funkcji
   - Bez tego `f.__name__` by≈Çoby `decorated_function` zamiast prawdziwej nazwy
   - Wa≈ºne dla debugowania i dokumentacji

3. **`def decorated_function(*args, **kwargs):`**
   - Wewnƒôtrzna funkcja, kt√≥ra faktycznie wykonuje sprawdzenie autoryzacji
   - `*args, **kwargs` przekazuje wszystkie argumenty do oryginalnej funkcji

4. **WyciƒÖganie tokena z nag≈Ç√≥wka:**
   ```python
   auth_header = request.headers['Authorization']
   token = auth_header.split(" ")[1]
   ```
   - Standardowy format JWT: `Authorization: Bearer eyJhbGc...`
   - Rozdzielamy po spacji: `["Bearer", "eyJhbGc..."]`
   - Bierzemy drugi element `[1]` - sam token

5. **Dekodowanie tokena JWT:**
   ```python
   data = jwt.decode(token, Config.JWT_SECRET_KEY, algorithms=['HS256'])
   ```
   - `jwt.decode()` weryfikuje podpis tokena u≈ºywajƒÖc `JWT_SECRET_KEY`
   - Je≈õli token jest sfa≈Çszowany lub zmieniony - wyrzuci `InvalidTokenError`
   - Je≈õli token wygas≈Ç - wyrzuci `ExpiredSignatureError`
   - `algorithms=['HS256']` okre≈õla algorytm szyfrowania
   - **HMAC-SHA256** - symetryczne szyfrowanie (ten sam klucz do enkrypcji i dekrypcji)

6. **Zapisanie ID u≈ºytkownika w kontek≈õcie Flask:**
   ```python
   g.user_id = current_user_id
   ```
   - `g` (global) to specjalny obiekt Flask dostƒôpny w ca≈Çym request lifecycle
   - Ka≈ºdy request ma sw√≥j w≈Çasny `g` (thread-safe)
   - Endpoint mo≈ºe p√≥≈∫niej u≈ºyƒá `g.user_id` aby wiedzieƒá kto jest zalogowany

7. **Obs≈Çuga b≈Çƒôd√≥w:**
   - **401 Unauthorized** - brak tokena lub token nieprawid≈Çowy
   - Ka≈ºdy rodzaj b≈Çƒôdu (brak tokena, wygas≈Çy, nieprawid≈Çowy) zwraca 401
   - Wa≈ºne: nie zdradzamy szczeg√≥≈Ç√≥w b≈Çƒôdu (security przez obscurity)

**Jak u≈ºywaƒá dekoratora:**
```python
@app.route('/api/Customers')
@require_auth  # ‚Üê Dodanie dekoratora chroni endpoint
def get_customers():
    user_id = g.user_id  # Dostƒôp do ID zalogowanego u≈ºytkownika
    # ... logika endpointu
```

---

#### **Funkcja `get_current_user()` - Pobieranie U≈ºytkownika**

```python
def get_current_user():
    """Pobiera obiekt aktualnego u≈ºytkownika z bazy danych"""
    from app.models import User
    user_id = get_current_user_id()
    if not user_id:
        # Sprawd≈∫ czy jest token w nag≈Ç√≥wku
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return None

        try:
            # WyciƒÖgnij token
            token = auth_header.split(' ')[1]
            # Zdekoduj token
            payload = jwt.decode(token, Config.JWT_SECRET_KEY, algorithms=['HS256'])
            # Pobierz user_id z tokenu
            user_id = payload.get('user_id') or int(payload.get('sub', 0))
        except:
            return None

    if user_id:
        return User.query.get(user_id)
    return None
```

**Wyja≈õnienie:**

1. **Po co ta funkcja?**
   - `@require_auth` tylko sprawdza czy u≈ºytkownik jest zalogowany
   - Ta funkcja **pobiera pe≈Çny obiekt User z bazy danych**
   - Potrzebna gdy endpoint musi znaƒá szczeg√≥≈Çy u≈ºytkownika (email, role, itp.)

2. **Dwuetapowe pobieranie:**
   - Najpierw pr√≥buje pobraƒá `user_id` z `g` (je≈õli by≈Ç `@require_auth`)
   - Je≈õli nie ma w `g` - dekoduje token rƒôcznie
   - Ta elastyczno≈õƒá pozwala u≈ºywaƒá funkcji nawet bez `@require_auth`

3. **`User.query.get(user_id)`**
   - SQLAlchemy query pobierajƒÖce u≈ºytkownika po ID (primary key)
   - `get()` zwraca `None` je≈õli nie znajdzie - bezpieczne

**Przyk≈Çad u≈ºycia:**
```python
@app.route('/api/Profile')
@require_auth
def get_profile():
    user = get_current_user()
    if not user:
        return jsonify({'error': 'User not found'}), 404

    return jsonify({
        'username': user.username,
        'email': user.email,
        'role': user.role.name
    })
```

---

## üîë BACKEND - KONTROLER UWIERZYTELNIANIA

### **Plik: `backend-python/app/controllers/auth.py`**

#### **Endpoint `/login` - Logowanie U≈ºytkownika**

```python
@auth_bp.route('/login', methods=['POST'])
def login():
    """Endpoint logowania"""
    try:
        # 1. Pobierz dane z requestu
        data = request.get_json()
        username = data.get('username')
        password = data.get('password')

        if not username or not password:
            return jsonify({'error': 'Brak nazwy u≈ºytkownika lub has≈Ça'}), 400

        # 2. Znajd≈∫ u≈ºytkownika w bazie danych
        user = User.query.filter_by(username=username).first()

        if not user:
            # Zapisz nieudanƒÖ pr√≥bƒô logowania
            login_history = LoginHistory(
                UserId=None,
                LoginTime=datetime.now(),
                IpAddress=request.remote_addr,
                UserAgent=request.headers.get('User-Agent', ''),
                Success=False
            )
            db.session.add(login_history)
            db.session.commit()

            return jsonify({'error': 'Nieprawid≈Çowe dane logowania'}), 401

        # 3. Sprawd≈∫ has≈Ço
        password_valid = check_password_hash(user.password_hash, password)

        if not password_valid:
            # Zapisz nieudanƒÖ pr√≥bƒô
            login_history = LoginHistory(
                UserId=user.id,
                LoginTime=datetime.now(),
                IpAddress=request.remote_addr,
                UserAgent=request.headers.get('User-Agent', ''),
                Success=False
            )
            db.session.add(login_history)
            db.session.commit()

            return jsonify({'error': 'Nieprawid≈Çowe dane logowania'}), 401

        # 4. Generuj token JWT
        payload = {
            'user_id': user.id,
            'username': user.username,
            'role': user.role.name if user.role else 'User',
            'exp': datetime.utcnow() + timedelta(hours=24)
        }

        token = jwt.encode(payload, Config.JWT_SECRET_KEY, algorithm='HS256')

        # 5. Zapisz udanƒÖ pr√≥bƒô logowania
        login_history = LoginHistory(
            UserId=user.id,
            LoginTime=datetime.now(),
            IpAddress=request.remote_addr,
            UserAgent=request.headers.get('User-Agent', ''),
            Success=True
        )
        db.session.add(login_history)
        db.session.commit()

        # 6. Zwr√≥ƒá token i dane u≈ºytkownika
        return jsonify({
            'token': token,
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'role': user.role.name if user.role else 'User'
            }
        }), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500
```

**Szczeg√≥≈Çowe wyja≈õnienie ka≈ºdego kroku:**

### **Krok 1: Pobieranie danych z requestu**

```python
data = request.get_json()
username = data.get('username')
password = data.get('password')
```

- **`request.get_json()`** parsuje JSON z body requestu
- Frontend wysy≈Ça: `{"username": "admin", "password": "pass123"}`
- Otrzymujemy Python dict: `{'username': 'admin', 'password': 'pass123'}`
- **`data.get('username')`** bezpiecznie pobiera warto≈õƒá (zwraca `None` je≈õli brak klucza)

**Walidacja:**
```python
if not username or not password:
    return jsonify({'error': 'Brak nazwy u≈ºytkownika lub has≈Ça'}), 400
```
- Sprawdzamy czy oba pola sƒÖ wype≈Çnione
- **400 Bad Request** - b≈ÇƒÖd po stronie klienta (niepoprawne dane)

---

### **Krok 2: Szukanie u≈ºytkownika w bazie**

```python
user = User.query.filter_by(username=username).first()
```

**Co siƒô dzieje:**
1. `User.query` - rozpoczyna query na tabeli `users`
2. `.filter_by(username=username)` - SQL: `WHERE username = 'admin'`
3. `.first()` - zwraca pierwszy wynik lub `None`

**Alternatywne podej≈õcia:**
- `.all()` - zwr√≥ci≈Çoby listƒô wszystkich pasujƒÖcych (ale username jest unique)
- `.filter(User.username == username)` - bardziej zaawansowana sk≈Çadnia

**Dlaczego u≈ºywamy SQLAlchemy zamiast raw SQL?**
```python
# ‚ùå Raw SQL - podatne na SQL injection
query = f"SELECT * FROM users WHERE username = '{username}'"
cursor.execute(query)

# ‚úÖ SQLAlchemy - automatyczna ochrona przed SQL injection
user = User.query.filter_by(username=username).first()
```

SQLAlchemy u≈ºywa **parametryzowanych zapyta≈Ñ** (prepared statements):
```sql
-- SQLAlchemy generuje:
SELECT * FROM users WHERE username = ?
-- i przekazuje parametr oddzielnie, bezpiecznie
```

---

### **Krok 3: Weryfikacja has≈Ça**

```python
password_valid = check_password_hash(user.password_hash, password)
```

**Jak dzia≈Ça `check_password_hash`:**

1. **W bazie danych przechowujemy hash, nie has≈Ço:**
   ```
   U≈ºytkownik wpisuje: "mypassword123"
   W bazie: "pbkdf2:sha256:260000$xyz..."
   ```

2. **Funkcja `check_password_hash` robi:**
   ```python
   # Pseudokod
   def check_password_hash(stored_hash, password):
       # WyciƒÖgnij s√≥l z hashowanego has≈Ça
       salt = extract_salt(stored_hash)

       # Zhashuj wprowadzone has≈Ço z tƒÖ samƒÖ solƒÖ
       new_hash = hash_with_salt(password, salt)

       # Por√≥wnaj hashe
       return new_hash == stored_hash
   ```

3. **Dlaczego nie mo≈ºna odwr√≥ciƒá hashu?**
   - Hash to funkcja jednostronna: `hash("password") = "abc123..."`
   - Nie da siƒô zrobiƒá: `unhash("abc123...") = "password"`
   - Mo≈ºna tylko por√≥wnaƒá hashe: czy `hash(wprowadzone) == hash(zapisane)`

**Przyk≈Çad bcrypt hash:**
```
$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyB3QK8J8yEu
‚îÇ  ‚îÇ  ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ                    ‚îî‚îÄ Hash (31 znak√≥w)
‚îÇ  ‚îÇ  ‚îî‚îÄ S√≥l (22 znaki)
‚îÇ  ‚îî‚îÄ Koszt (2^12 = 4096 iteracji)
‚îî‚îÄ Algorytm (bcrypt)
```

---

### **Krok 4: Generowanie tokena JWT**

```python
payload = {
    'user_id': user.id,
    'username': user.username,
    'role': user.role.name if user.role else 'User',
    'exp': datetime.utcnow() + timedelta(hours=24)
}

token = jwt.encode(payload, Config.JWT_SECRET_KEY, algorithm='HS256')
```

**Struktura JWT:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6IkFkbWluIiwiZXhwIjoxNzA5MzI0ODAwfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PAYLOAD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SIGNATURE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Rozkodowany token:**

**Header:**
```json
{
  "alg": "HS256",  // Algorytm: HMAC-SHA256
  "typ": "JWT"     // Typ tokena: JWT
}
```

**Payload:**
```json
{
  "user_id": 1,
  "username": "admin",
  "role": "Admin",
  "exp": 1709324800  // Timestamp wyga≈õniƒôcia (24h od teraz)
}
```

**Signature:**
```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  JWT_SECRET_KEY
)
```

**Dlaczego JWT jest bezpieczny:**
1. **Payload jest base64 encoded, NIE encrypted** - ka≈ºdy mo≈ºe go odczytaƒá
2. **Bezpiecze≈Ñstwo zapewnia SIGNATURE** - nikt nie mo≈ºe go zmieniƒá bez SECRET_KEY
3. Je≈õli kto≈õ zmieni payload, signature siƒô nie zgodzi ‚Üí token odrzucony

**Przyk≈Çad ataku:**
```
AtakujƒÖcy zmienia:
{"user_id": 1, "role": "Admin"} ‚Üí {"user_id": 1, "role": "SuperAdmin"}

Token wynikowy ma nieprawid≈Çowy podpis:
verify_signature(token, SECRET_KEY) ‚Üí False
Server odrzuca token ‚Üí 401 Unauthorized
```

---

### **Krok 5: Zapisywanie historii logowania**

```python
login_history = LoginHistory(
    UserId=user.id,
    LoginTime=datetime.now(),
    IpAddress=request.remote_addr,
    UserAgent=request.headers.get('User-Agent', ''),
    Success=True
)
db.session.add(login_history)
db.session.commit()
```

**Po co zapisujemy historiƒô:**
- **Audyt bezpiecze≈Ñstwa** - kto i kiedy siƒô logowa≈Ç
- **Wykrywanie podejrzanych aktywno≈õci** - logowania z nowych IP
- **Compliance** - wymogi prawne (RODO, SOX)
- **Debugging** - analiza problem√≥w u≈ºytkownik√≥w

**`request.remote_addr`:**
- IP adres klienta: `192.168.1.100`, `127.0.0.1`
- Je≈õli za proxy/load balancer: `request.headers.get('X-Forwarded-For')`

**`User-Agent`:**
```
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
```
Zawiera:
- System operacyjny: Windows 10
- PrzeglƒÖdarka: Chrome 120
- Silnik renderujƒÖcy: WebKit

---

## ‚öõÔ∏è FRONTEND WEB - KONTEKST AUTORYZACJI

### **Plik: `crm-ui/src/context/AuthContext.tsx`**

#### **Komponent `AuthProvider` - Provider Kontekstu**

```typescript
export const AuthProvider = ({ children }: { children: ReactNode }) => {
    const [user, setUser] = useState<User | null>(null);
    const [loading, setLoading] = useState(true);
    const { openModal } = useModal();

    useEffect(() => {
        // Pobieramy token JWT z localStorage przeglƒÖdarki
        const token = localStorage.getItem("token");
        if (token) {
            try {
                // Dekodujemy token JWT aby wyciƒÖgnƒÖƒá dane u≈ºytkownika
                const decoded = jwtDecode<JwtPayload>(token);

                // Pobierz dane u≈ºytkownika z tokenu
                const username = decoded.username || decoded.sub;
                const role = decoded.role;

                // Ustawiamy dane u≈ºytkownika w stanie
                setUser({
                    username: username || '',
                    role: role || '',
                });
            } catch (error) {
                // W przypadku b≈Çƒôdu dekodowania (token nieprawid≈Çowy/wygas≈Çy)
                console.error("B≈ÇƒÖd dekodowania tokena:", error);
                localStorage.removeItem("token");
                setUser(null);
            }
        }
        setLoading(false);
    }, []);

    const logout = () => {
        localStorage.removeItem("token");
        setUser(null);
    };

    return (
        <AuthContext.Provider value={{ user, loading, logout }}>
            {children}
        </AuthContext.Provider>
    );
};
```

**Szczeg√≥≈Çowe wyja≈õnienie:**

### **React Context API - Po co?**

**Problem bez Context:**
```typescript
// App.tsx
function App() {
  const [user, setUser] = useState(null);

  return <Dashboard user={user} setUser={setUser} />;
}

// Dashboard.tsx
function Dashboard({ user, setUser }) {
  return <Sidebar user={user} setUser={setUser} />;
}

// Sidebar.tsx
function Sidebar({ user, setUser }) {
  return <UserMenu user={user} setUser={setUser} />;
}

// UserMenu.tsx - w ko≈Ñcu u≈ºywamy!
function UserMenu({ user, setUser }) {
  return <div>{user.name}</div>;
}
```
**Prop drilling** - przekazywanie props przez wiele poziom√≥w

**RozwiƒÖzanie z Context:**
```typescript
// App.tsx
<AuthProvider>
  <Dashboard />
</AuthProvider>

// UserMenu.tsx - bezpo≈õredni dostƒôp!
function UserMenu() {
  const { user } = useAuth();
  return <div>{user.name}</div>;
}
```

---

### **localStorage - Przechowywanie Tokena**

```typescript
const token = localStorage.getItem("token");
```

**Jak dzia≈Ça localStorage:**
- **Browser API** do przechowywania danych w przeglƒÖdarce
- Dane sƒÖ **persistent** - zostajƒÖ po zamkniƒôciu przeglƒÖdarki
- **5-10MB** limitu (zale≈ºy od przeglƒÖdarki)
- **Synchroniczny API** - blokuje JS thread

**Alternatywy:**
1. **sessionStorage** - usuwa dane po zamkniƒôciu karty
2. **Cookies** - automatycznie wysy≈Çane z ka≈ºdym requestem
3. **IndexedDB** - du≈ºa baza danych w przeglƒÖdarce

**Bezpiecze≈Ñstwo localStorage:**
```typescript
// ‚úÖ Bezpieczne dla JWT w header Authorization
localStorage.setItem("token", jwt);

// ‚ùå Podatne na XSS (Cross-Site Scripting)
// Je≈õli atakujƒÖcy wstrzyknie JS: localStorage.getItem("token")
```

**Ochrona przed XSS:**
1. **Content Security Policy (CSP)** - blokuje nieautoryzowany JS
2. **React automatycznie escapuje dane** - chroni przed `<script>` injection
3. **Sanityzacja input√≥w** - oczyszczanie danych od u≈ºytkownika

---

### **jwt-decode - Dekodowanie Tokena**

```typescript
const decoded = jwtDecode<JwtPayload>(token);
```

**Co robi `jwtDecode`:**
```typescript
// Token JWT:
"eyJhbGc...xyz"

// Po dekodowaniu:
{
  user_id: 1,
  username: "admin",
  role: "Admin",
  exp: 1709324800,
  iat: 1709238400
}
```

**WA≈ªNE:**
- **`jwtDecode` NIE weryfikuje podpisu** - tylko dekoduje base64
- Weryfikacja podpisu odbywa siƒô na **backendzie**
- Frontend tylko **czyta** dane z tokenu dla UX (np. poka≈º nazwƒô u≈ºytkownika)

**Weryfikacja wyga≈õniƒôcia:**
```typescript
if (decoded.exp * 1000 < Date.now()) {
  // Token wygas≈Ç
  localStorage.removeItem("token");
}
```
- `decoded.exp` to **Unix timestamp w sekundach**
- `Date.now()` zwraca **milisekundy**
- Dlatego mno≈ºymy: `exp * 1000`

---

### **Axios Interceptor - Globalna Obs≈Çuga B≈Çƒôd√≥w**

```typescript
const interceptor = axios.interceptors.response.use(
    response => response,  // Udane odpowiedzi - przeka≈º dalej
    error => {
        if (error.response) {
            const status = error.response.status;

            // Dla b≈Çƒôd√≥w 401 (Unauthorized) - wyloguj u≈ºytkownika
            if (status === 401) {
                localStorage.removeItem('token');
                delete axios.defaults.headers.common['Authorization'];
                setUser(null);
                return Promise.reject(error);
            }

            // Dla innych b≈Çƒôd√≥w - poka≈º modal
            const message = error.response.data?.message || `B≈ÇƒÖd serwera: ${status}`;
            openModal({
                type: 'error',
                title: `B≈ÇƒÖd ${status}`,
                message: message,
            });
        }
        return Promise.reject(error);
    }
);
```

**Co to jest Interceptor:**
- **Middleware dla Axios** - przechwytuje wszystkie requesty/responses
- Uruchamia siƒô **przed** `.then()` lub `.catch()` w komponencie
- Pozwala na **globalnƒÖ logikƒô** bez duplikowania w ka≈ºdym komponencie

**Flow z interceptorem:**
```
Component: api.get('/Customers')  // U≈ºywamy api, nie axios bezpo≈õrednio
    ‚Üì
Request Interceptor (dodaje token z localStorage)
    ‚Üì
HTTP Request ‚Üí Server (http://localhost:5000/api/Customers)
    ‚Üì
HTTP Response ‚Üê Server
    ‚Üì
Response Interceptor (sprawdza b≈Çƒôdy, obs≈Çuguje 401)
    ‚Üì
Component: .then(response => ...) lub .catch(error => ...)
```

**Dlaczego 401 ‚Üí logout:**
- **401 Unauthorized** = token nieprawid≈Çowy/wygas≈Çy
- U≈ºytkownik musi siƒô zalogowaƒá ponownie
- Automatyczny logout poprawia UX (nie trzeba klikaƒá "wyloguj")

---

## üì± MOBILE - KONTEKST AUTORYZACJI

### **Plik: `crm-mobile/context/AuthContext.tsx`**

#### **SecureStore - Bezpieczne Przechowywanie Tokena**

```typescript
const storage = {
    async setItem(key: string, value: string) {
        if (Platform.OS === 'web') {
            localStorage.setItem(key, value);
        } else {
            await SecureStore.setItemAsync(key, value);
        }
    },
    async getItem(key: string) {
        if (Platform.OS === 'web') {
            return localStorage.getItem(key);
        } else {
            return await SecureStore.getItemAsync(key);
        }
    },
    async deleteItem(key: string) {
        if (Platform.OS === 'web') {
            localStorage.removeItem(key);
        } else {
            await SecureStore.deleteItemAsync(key);
        }
    },
};
```

**Dlaczego SecureStore jest bezpieczniejszy:**

**Android:**
- U≈ºywa **Android Keystore** - hardware-backed encryption
- Klucze przechowywane w **TEE (Trusted Execution Environment)** lub **Secure Element**
- **Biometric authentication** mo≈ºna w≈ÇƒÖczyƒá

**iOS:**
- U≈ºywa **iOS Keychain** - zaszyfrowany storage
- Dane sƒÖ **powiƒÖzane z aplikacjƒÖ** - inne apki nie majƒÖ dostƒôpu
- **Touch ID/Face ID** integracja

**localStorage (web):**
- **Niezaszyfrowane** - przechowywane jako plain text
- Dostƒôpne przez JavaScript - podatne na XSS
- Ale: wystarczajƒÖce dla web (security przez HTTPS + CSP)

---

#### **Funkcja `login()` - Logowanie w Mobile**

```typescript
const login = async (username: any, password: any) => {
    try {
        const result = await axios.post('/api/Auth/login', { username, password });
        const token = result.data.token;

        await storage.setItem(TOKEN_KEY, token);
        axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;

        setAuthState({
            token: token,
            isAuthenticated: true,
            isLoading: false,
        });
    } catch (e) {
        console.error("B≈ÇƒÖd logowania:", e);
        throw new Error("Logowanie nie powiod≈Ço siƒô");
    }
};
```

**Szczeg√≥≈Çy:**

1. **`await axios.post('/api/Auth/login', ...)`**
   - UWAGA: W mobile **u≈ºywamy axios bezpo≈õrednio** (w AuthContext skonfigurowane `axios.defaults.baseURL`)
   - W web frontend u≈ºywamy `api` z `services/api.ts`
   - POST request do endpointu logowania
   - Wysy≈Ça JSON: `{"username": "admin", "password": "pass"}`
   - Zwraca: `{"token": "eyJhbGc...", "user": {...}}`

2. **`await storage.setItem(TOKEN_KEY, token)`**
   - Zapisuje token w SecureStore (na urzƒÖdzeniu)
   - **Async operation** - czekamy na zako≈Ñczenie
   - Token przetrwa zamkniƒôcie aplikacji

3. **`axios.defaults.headers.common['Authorization']`**
   - Ustawia **globalny header dla wszystkich request√≥w**
   - Ka≈ºdy kolejny request bƒôdzie mia≈Ç: `Authorization: Bearer eyJhbGc...`
   - Nie trzeba rƒôcznie dodawaƒá tokena do ka≈ºdego zapytania

**R√≥≈ºnica miƒôdzy web a mobile:**
```typescript
// Web - synchroniczny
localStorage.setItem("token", token);

// Mobile - asynchroniczny (trzeba await)
await SecureStore.setItemAsync("token", token);
```

---

### **useEffect - Automatyczne Logowanie**

```typescript
useEffect(() => {
    const loadToken = async () => {
        const token = await storage.getItem(TOKEN_KEY);
        if (token) {
            try {
                const decodedToken: any = jwtDecode(token);
                if (decodedToken.exp * 1000 < Date.now()) {
                    // Token wygas≈Ç
                    await storage.deleteItem(TOKEN_KEY);
                    setAuthState({ token: null, isAuthenticated: false, isLoading: false });
                } else {
                    // Token OK - automatyczne logowanie
                    axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
                    setAuthState({ token: token, isAuthenticated: true, isLoading: false });
                }
            } catch (e) {
                await storage.deleteItem(TOKEN_KEY);
                setAuthState({ token: null, isAuthenticated: false, isLoading: false });
            }
        } else {
            setAuthState({ token: null, isAuthenticated: false, isLoading: false });
        }
    };
    loadToken();
}, []);
```

**Flow automatycznego logowania:**
```
User otwiera aplikacjƒô
    ‚Üì
useEffect uruchamia loadToken()
    ‚Üì
Sprawd≈∫ czy jest token w SecureStore
    ‚Üì
Je≈õli TAK ‚Üí Zdekoduj token
    ‚Üì
Sprawd≈∫ czy token NIE wygas≈Ç
    ‚Üì
Je≈õli OK ‚Üí Ustaw Authorization header
    ‚Üì
Ustaw isAuthenticated = true
    ‚Üì
User widzi dashboard (bez logowania)
```

**Po co to?**
- **Lepszy UX** - user nie musi logowaƒá siƒô za ka≈ºdym razem
- **Persist session** - sesja przetrwa zamkniƒôcie aplikacji
- **24h token** - przez 24h od logowania nie trzeba wpisywaƒá has≈Ça

---

## üìä PODSUMOWANIE FLOW AUTORYZACJI

### **Pe≈Çny flow: Od logowania do chronionego requestu**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. USER LOGUJE SIƒò                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    Frontend Web: api.post('/Auth/login', {username, password})
    Frontend Mobile: axios.post('/api/Auth/login', {username, password})
        ‚Üì
    Backend: auth.py ‚Üí login()
        ‚Üì
    Sprawd≈∫ username w bazie
        ‚Üì
    Weryfikuj has≈Ço: check_password_hash(hash, password)
        ‚Üì
    Generuj JWT: jwt.encode(payload, SECRET_KEY)
        ‚Üì
    Zapisz historiƒô logowania
        ‚Üì
    Zwr√≥ƒá: {token: "eyJhbGc...", user: {...}}
        ‚Üì
    Frontend Web: localStorage.setItem("token", token)
    Frontend Mobile: SecureStore.setItemAsync("my-jwt", token)
        ‚Üì
    Ustaw header dla przysz≈Çych request√≥w

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. USER OTWIERA STRONƒò Z KLIENTAMI                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    Frontend Web: api.get('/Customers')
    Frontend Mobile: axios.get('/api/Customers')
        ‚Üì
    Request Interceptor automatycznie dodaje: Authorization: Bearer eyJhbGc...
        ‚Üì
    Backend: customers.py ‚Üí get_customers()
        ‚Üì
    Dekorator: @require_auth
        ‚Üì
    WyciƒÖgnij token z nag≈Ç√≥wka Authorization
        ‚Üì
    Dekoduj: jwt.decode(token, SECRET_KEY)
        ‚Üì
    Sprawd≈∫ czy token NIE wygas≈Ç
        ‚Üì
    Zapisz user_id w g.user_id
        ‚Üì
    Wywo≈Çaj oryginalnƒÖ funkcjƒô: get_customers()
        ‚Üì
    Pobierz klient√≥w z bazy: Customer.query.all()
        ‚Üì
    Zwr√≥ƒá: [{id: 1, name: "Jan"}, ...]
        ‚Üì
    Frontend: Wy≈õwietl listƒô klient√≥w

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. TOKEN WYGASA                                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    Frontend: api.get('/Customers') lub axios.get('/api/Customers')
        ‚Üì
    Backend: jwt.decode(token) ‚Üí ExpiredSignatureError
        ‚Üì
    Zwr√≥ƒá: 401 Unauthorized
        ‚Üì
    Frontend: Response Interceptor przechwytuje 401
        ‚Üì
    localStorage.removeItem('token')
        ‚Üì
    setUser(null)
        ‚Üì
    Redirect do /login
```

---

**Ten dokument zawiera szczeg√≥≈Çowe wyja≈õnienia najwa≈ºniejszych metod i funkcji w systemie CRM. Ka≈ºda funkcja jest opisana krok po kroku z przyk≈Çadami kodu i wyja≈õnieniami technicznymi.**
